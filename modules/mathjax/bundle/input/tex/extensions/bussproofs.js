(()=>{"use strict";var e={d:(t,n)=>{for(var o in n)e.o(n,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:n[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{balanceRules:()=>O,clearDocument:()=>H,getProperty:()=>j,makeBsprAttributes:()=>G,removeProperty:()=>D,saveDocument:()=>K,setProperty:()=>q});var n={};e.r(n),e.d(n,{ProofTreeItem:()=>Q});var o={};e.r(o),e.d(o,{default:()=>Z});var r={};e.r(r),e.d(r,{BussproofsConfiguration:()=>re});const i=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(i.GLOBAL,i.isObject,i.combineConfig,i.combineDefaults,i.combineWithMathJax),s=(i.MathJax,MathJax._.input.tex.HandlerTypes),c=s.ConfigurationType,l=s.HandlerType,d=MathJax._.input.tex.Configuration,f=d.Configuration,u=(d.ConfigurationHandler,d.ParserConfiguration,MathJax._.input.tex.TexError.default),p=MathJax._.input.tex.StackItem,h=(p.MmlStack,p.BaseItem),m=MathJax._.input.tex.Stack.default,g=MathJax._.input.tex.NodeUtil.default,y=MathJax._.input.tex.UnitUtil.UnitUtil;let P=null,w=null;const x=function(e){w.root=e;const{w:t}=P.outputJax.getBBox(w,P);return t},T=function(e){let t=0;for(;e&&!g.isType(e,"mtable");){if(g.isType(e,"text"))return null;g.isType(e,"mrow")?(e=e.childNodes[0],t=0):(e=e.parent.childNodes[t],t++)}return e},b=function(e,t){return e.childNodes["up"===t?1:0].childNodes[0].childNodes[0].childNodes[0].childNodes[0]},M=function(e,t){return e.childNodes[t].childNodes[0].childNodes[0]},N=function(e){return M(e,0)},C=function(e){return M(e,e.childNodes.length-1)},I=function(e,t){return e.childNodes["up"===t?0:1].childNodes[0].childNodes[0].childNodes[0]},L=function(e){for(;e&&!g.isType(e,"mtd");)e=e.parent;return e},S=function(e){return e.parent.childNodes[e.parent.childNodes.indexOf(e)+1]},k=function(e){for(;e&&null==j(e,"inference");)e=e.parent;return e},A=function(e,t,n=!1){let o=0;if(e===t)return o;if(e!==t.parent){const r=e.childNodes,i=n?r.length-1:0;g.isType(r[i],"mspace")&&(o+=x(r[i])),e=t.parent}if(e===t)return o;const r=e.childNodes,i=n?r.length-1:0;return r[i]!==t&&(o+=x(r[i])),o},R=function(e,t=!1){const n=T(e),o=I(n,j(n,"inferenceRule"));return A(e,n,t)+(x(n)-x(o))/2},v=function(e,t,n,o=!1){if(0===n)return;if(j(t,"inferenceRule")||j(t,"labelledRule")){const n=e.nodeFactory.create("node","mrow");t.parent.replaceChild(n,t),n.setChildren([t]),B(t,n),t=n}const r=o?t.childNodes.length-1:0;let i=t.childNodes[r];g.isType(i,"mspace")?g.setAttribute(i,"width",y.em(y.dimen2em(g.getAttribute(i,"width"))+n)):(i=e.nodeFactory.create("node","mspace",[],{width:y.em(n)}),o?t.appendChild(i):(i.parent=t,t.childNodes.unshift(i)))},B=function(e,t){["inference","proof","labelledRule"].forEach((n=>{const o=j(e,n);null!=o&&(q(t,n,o),D(e,n))}))},J=function(e,t,n,o,r){const i=e.nodeFactory.create("node","mspace",[],{width:y.em(r)});if("left"===o){const e=t.childNodes[n].childNodes[0];i.parent=e,e.childNodes.unshift(i)}else t.childNodes[n].appendChild(i);q(t.parent,"sequentAdjust_"+o,r)},_=function(e,t){let n=t.pop();for(;t.length;){const o=t.pop(),[r,i]=E(n,o);j(n.parent,"axiom")&&(J(e,r<0?n:o,0,"left",Math.abs(r)),J(e,i<0?n:o,2,"right",Math.abs(i))),n=o}},E=function(e,t){const n=x(e.childNodes[2]),o=x(t.childNodes[2]);return[x(e.childNodes[0])-x(t.childNodes[0]),n-o]},O=function(e){w=new e.document.options.MathItem("",null,e.math.display);const t=e.data;!function(e){const t=e.nodeLists.sequent;if(t)for(let n,o=t.length-1;n=t[o];o--){if(j(n,"sequentProcessed")){D(n,"sequentProcessed");continue}const t=[];let o=k(n);if(1===j(o,"inference")){for(t.push(n);1===j(o,"inference");){o=T(o);const e=N(b(o,j(o,"inferenceRule"))),r=j(e,"inferenceRule")?I(e,j(e,"inferenceRule")):e;j(r,"sequent")&&(n=r.childNodes[0],t.push(n),q(n,"sequentProcessed",!0)),o=e}_(e,t)}}}(t);const n=t.nodeLists.inference||[];let o=0;for(const e of n){const n=j(e,"proof"),r=T(e),i=b(r,j(r,"inferenceRule")),a=N(i);let s=0;if(j(a,"inference")){const n=R(a);if(n){v(t,a,-n);const o=A(e,r,!1);v(t,e,n-o),s=n-o}}const c=C(i);if(null==j(c,"inference"))continue;const l=R(c,!0);v(t,c,-l,!0);const d=A(e,r,!0),f=(x(r)-x(i.parent))/2;let u;if(v(t,e,f<s?-f:-s),o=Math.max(0,Math.max(0,o+l-d)-f),n||!(u=L(e))){v(t,j(e,"proof")?e:e.parent,o,!0);continue}const p=S(u);if(p){const e=t.nodeFactory.create("node","mspace",[],{width:y.em(o)});p.appendChild(e),o=0}else k(u)}},F="bspr_",U=RegExp("^"+F),q=function(e,t,n){g.setProperty(e,F+t,n)},j=function(e,t){return g.getProperty(e,F+t)},D=function(e,t){e.removeProperty(F+t)},G=function(e){e.data.root.walkTree(((e,t)=>{const n=[];e.getPropertyNames().forEach((t=>{t.match(U)&&n.push(t+":"+e.getProperty(t))})),n.length&&g.setAttribute(e,"semantics",n.join(";"))}))},K=function(e){if(P=e.document,!("getBBox"in P.outputJax))throw Error("The bussproofs extension requires an output jax with a getBBox() method")},H=function(e){P=null};class Q extends h{constructor(){super(...arguments),this.leftLabel=null,this.rigthLabel=null,this.innerStack=new m(this.factory,{},!0)}get kind(){return"proofTree"}checkItem(e){if(e.isKind("end")&&"prooftree"===e.getName()){const t=this.toMml();return q(t,"proof",!0),[[this.factory.create("mml",t),e],!0]}if(e.isKind("stop"))throw new u("EnvMissingEnd","Missing \\end{%1}",this.getName());return this.innerStack.Push(e),h.fail}toMml(){const e=super.toMml(),t=this.innerStack.Top();if(t.isKind("start")&&!t.Size())return e;this.innerStack.Push(this.factory.create("stop"));const n=this.innerStack.Top().toMml();return this.create("node","mrow",[n,e],{})}}const V=MathJax._.input.tex.TexParser.default,z=MathJax._.input.tex.ParseUtil,$=(z.KeyValueDef,z.KeyValueTypes,z.ParseUtil);function W(e,t){const n=$.internalMath(e,y.trimSpaces(t),0);if(!n[0].childNodes[0].childNodes.length)return e.create("node","mrow",[]);const o=e.create("node","mspace",[],{width:".5ex"}),r=e.create("node","mspace",[],{width:".5ex"});return e.create("node","mrow",[o,...n,r])}function X(e,t,n,o,r,i,a){const s=e.create("node","mtr",[e.create("node","mtd",[t],{})],{}),c=e.create("node","mtr",[e.create("node","mtd",n,{})],{});let l,d,f,u,p=e.create("node","mtable",a?[c,s]:[s,c],{align:"top 2",rowlines:i,framespacing:"0 0"});if(q(p,"inferenceRule",a?"up":"down"),o&&(l=e.create("node","mpadded",[o],{height:".25em",depth:"+.25em",width:"+.5ex",voffset:"-.25em"}),q(l,"prooflabel","left")),r&&(d=e.create("node","mpadded",[r],{height:"-.25em",depth:"+.25em",width:"+.5ex",voffset:"-.25em",lspace:".5ex"}),q(d,"prooflabel","right")),o&&r)f=[l,p,d],u="both";else if(o)f=[l,p],u="left";else{if(!r)return p;f=[p,d],u="right"}return p=e.create("node","mrow",f),q(p,"labelledRule",u),p}function Y(e,t){if("$"!==e.GetNext())throw new u("IllegalUseOfCommand","Use of %1 does not match its definition.",t);e.i++;const n=e.GetUpTo(t,"$");if(!n.includes("\\fCenter"))throw new u("MissingProofCommand","Missing %1 in %2.","\\fCenter",t);const[o,r]=n.split("\\fCenter"),i=new V(o,e.stack.env,e.configuration).mml(),a=new V(r,e.stack.env,e.configuration).mml(),s=new V("\\fCenter",e.stack.env,e.configuration).mml(),c=e.create("node","mtd",[i],{}),l=e.create("node","mtd",[s],{}),d=e.create("node","mtd",[a],{}),f=e.create("node","mtr",[c,l,d],{}),p=e.create("node","mtable",[f],{columnspacing:".5ex",columnalign:"center 2"});return q(p,"sequent",!0),e.configuration.addNode("sequent",f),p}const Z={Prooftree(e,t){e.Push(t);return e.itemFactory.create("proofTree").setProperties({name:t.getName(),line:"solid",currentLine:"solid",rootAtTop:!1})},Axiom(e,t){const n=e.stack.Top();if("proofTree"!==n.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");const o=W(e,e.GetArgument(t));q(o,"axiom",!0),n.Push(o)},Inference(e,t,n){const o=e.stack.Top();if("proofTree"!==o.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");if(o.Size()<n)throw new u("BadProofTree","Proof tree badly specified.");const r=o.getProperty("rootAtTop"),i=1!==n||o.Peek()[0].childNodes.length?n:0,a=[];do{a.length&&a.unshift(e.create("node","mtd",[],{})),a.unshift(e.create("node","mtd",[o.Pop()],{rowalign:r?"top":"bottom"})),n--}while(n>0);const s=e.create("node","mtr",a,{}),c=e.create("node","mtable",[s],{framespacing:"0 0"}),l=W(e,e.GetArgument(t)),d=o.getProperty("currentLine");d!==o.getProperty("line")&&o.setProperty("currentLine",o.getProperty("line"));const f=X(e,c,[l],o.getProperty("left"),o.getProperty("right"),d,r);o.setProperty("left",null),o.setProperty("right",null),q(f,"inference",i),e.configuration.addNode("inference",f),o.Push(f)},Label(e,t,n){const o=e.stack.Top();if("proofTree"!==o.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");const r=$.internalMath(e,e.GetArgument(t),0),i=r.length>1?e.create("node","mrow",r,{}):r[0];o.setProperty(n,i)},SetLine(e,t,n,o){const r=e.stack.Top();if("proofTree"!==r.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");r.setProperty("currentLine",n),o&&r.setProperty("line",n)},RootAtTop(e,t,n){const o=e.stack.Top();if("proofTree"!==o.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");o.setProperty("rootAtTop",n)},AxiomF(e,t){const n=e.stack.Top();if("proofTree"!==n.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");const o=Y(e,t);q(o,"axiom",!0),n.Push(o)},FCenter(e,t){},InferenceF(e,t,n){const o=e.stack.Top();if("proofTree"!==o.kind)throw new u("IllegalProofCommand","Proof commands only allowed in prooftree environment.");if(o.Size()<n)throw new u("BadProofTree","Proof tree badly specified.");const r=o.getProperty("rootAtTop"),i=1!==n||o.Peek()[0].childNodes.length?n:0,a=[];do{a.length&&a.unshift(e.create("node","mtd",[],{})),a.unshift(e.create("node","mtd",[o.Pop()],{rowalign:r?"top":"bottom"})),n--}while(n>0);const s=e.create("node","mtr",a,{}),c=e.create("node","mtable",[s],{framespacing:"0 0"}),l=Y(e,t),d=o.getProperty("currentLine");d!==o.getProperty("line")&&o.setProperty("currentLine",o.getProperty("line"));const f=X(e,c,[l],o.getProperty("left"),o.getProperty("right"),d,r);o.setProperty("left",null),o.setProperty("right",null),q(f,"inference",i),e.configuration.addNode("inference",f),o.Push(f)}},ee=MathJax._.input.tex.ParseMethods.default,te=MathJax._.input.tex.TokenMap,ne=(te.parseResult,te.AbstractTokenMap,te.RegExpMap,te.AbstractParseMap,te.CharacterMap,te.DelimiterMap,te.MacroMap,te.CommandMap),oe=te.EnvironmentMap;new ne("Bussproofs-macros",{AxiomC:Z.Axiom,UnaryInfC:[Z.Inference,1],BinaryInfC:[Z.Inference,2],TrinaryInfC:[Z.Inference,3],QuaternaryInfC:[Z.Inference,4],QuinaryInfC:[Z.Inference,5],RightLabel:[Z.Label,"right"],LeftLabel:[Z.Label,"left"],AXC:Z.Axiom,UIC:[Z.Inference,1],BIC:[Z.Inference,2],TIC:[Z.Inference,3],RL:[Z.Label,"right"],LL:[Z.Label,"left"],noLine:[Z.SetLine,"none",!1],singleLine:[Z.SetLine,"solid",!1],solidLine:[Z.SetLine,"solid",!1],dashedLine:[Z.SetLine,"dashed",!1],alwaysNoLine:[Z.SetLine,"none",!0],alwaysSingleLine:[Z.SetLine,"solid",!0],alwaysSolidLine:[Z.SetLine,"solid",!0],alwaysDashedLine:[Z.SetLine,"dashed",!0],rootAtTop:[Z.RootAtTop,!0],alwaysRootAtTop:[Z.RootAtTop,!0],rootAtBottom:[Z.RootAtTop,!1],alwaysRootAtBottom:[Z.RootAtTop,!1],fCenter:Z.FCenter,Axiom:Z.AxiomF,UnaryInf:[Z.InferenceF,1],BinaryInf:[Z.InferenceF,2],TrinaryInf:[Z.InferenceF,3],QuaternaryInf:[Z.InferenceF,4],QuinaryInf:[Z.InferenceF,5]}),new oe("Bussproofs-environments",ee.environment,{prooftree:[Z.Prooftree,null,!1]});const re=f.create("bussproofs",{[c.HANDLER]:{[l.MACRO]:["Bussproofs-macros"],[l.ENVIRONMENT]:["Bussproofs-environments"]},[c.ITEMS]:{[Q.prototype.kind]:Q},[c.PREPROCESSORS]:[[K,1]],[c.POSTPROCESSORS]:[[H,3],[G,2],[O,1]]});MathJax.loader&&MathJax.loader.checkVersion("[tex]/bussproofs","4.0.0","tex-extension"),a({_:{input:{tex:{bussproofs:{BussproofsConfiguration:r,BussproofsItems:n,BussproofsMethods:o,BussproofsUtil:t}}}}})})();