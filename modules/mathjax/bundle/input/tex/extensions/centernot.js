(()=>{"use strict";var e={d:(t,n)=>{for(var a in n)e.o(n,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:n[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{CenternotConfiguration:()=>x,filterCenterOver:()=>f});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),o=(n.MathJax,MathJax._.input.tex.HandlerTypes),r=o.ConfigurationType,i=(o.HandlerType,MathJax._.input.tex.Configuration),c=i.Configuration,d=(i.ConfigurationHandler,i.ParserConfiguration,MathJax._.input.tex.TexParser.default),p=MathJax._.input.tex.NodeUtil.default,s=MathJax._.input.tex.TokenMap,l=(s.parseResult,s.AbstractTokenMap,s.RegExpMap,s.AbstractParseMap,s.CharacterMap,s.DelimiterMap,s.MacroMap,s.CommandMap),u=(s.EnvironmentMap,MathJax._.input.tex.base.BaseMethods);u.splitAlignArray;function f({data:e}){for(const t of e.getList("centerOver")){const e=p.getTexClass(t.childNodes[0].childNodes[0]);null!==e&&p.setProperties(t.parent.parent.parent.parent.parent.parent,{texClass:e})}}new l("centernot",{centerOver:function(e,t){const n="{"+e.GetArgument(t)+"}",a=e.ParseArg(t),o=new d(n,e.stack.env,e.configuration).mml(),r=e.create("node","TeXAtom",[new d(n,e.stack.env,e.configuration).mml(),e.create("node","mpadded",[e.create("node","mpadded",[a],{width:0,lspace:"-.5width"}),e.create("node","mphantom",[o])],{width:0,lspace:"-.5width"})]);e.configuration.addNode("centerOver",o),e.Push(r)},centernot:[u.default.Macro,"\\centerOver{#1}{{\u29f8}}",1]});const x=c.create("centernot",{[r.HANDLER]:{macro:["centernot"]},[r.POSTPROCESSORS]:[f]});MathJax.loader&&MathJax.loader.checkVersion("[tex]/centernot","4.0.0","tex-extension"),a({_:{input:{tex:{centernot:{CenternotConfiguration:t}}}}})})();