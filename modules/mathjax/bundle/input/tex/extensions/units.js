(()=>{"use strict";var t={d:(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{UnitsConfiguration:()=>m,UnitsMethods:()=>p});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),i=(n.MathJax,MathJax._.input.tex.HandlerTypes),o=i.ConfigurationType,r=i.HandlerType,s=MathJax._.input.tex.Configuration,c=s.Configuration,u=(s.ConfigurationHandler,s.ParserConfiguration,MathJax._.input.tex.TexParser.default),l=MathJax._.input.tex.TokenMap,g=(l.parseResult,l.AbstractTokenMap,l.RegExpMap,l.AbstractParseMap,l.CharacterMap,l.DelimiterMap,l.MacroMap,l.CommandMap),p=(l.EnvironmentMap,{Unit(t,e){const n=t.GetBrackets(e);let a=`\\mathrm{${t.GetArgument(e)}}`;n&&(a=n+(t.options.units.loose?"~":"\\,")+a),t.string=a+t.string.slice(t.i),t.i=0},UnitFrac(t,e){const n=t.GetBrackets(e);let a=`\\nicefrac[\\mathrm]{${t.GetArgument(e)}}{${t.GetArgument(e)}}`;n&&(a=n+(t.options.units.loose?"~":"\\,")+a),t.string=a+t.string.slice(t.i),t.i=0},NiceFrac(t,e){const n=t.GetBrackets(e,"\\mathrm"),a=t.GetArgument(e),i=t.GetArgument(e),o=new u(`${n}{${a}}`,Object.assign({},t.stack.env),t.configuration).mml(),r=new u(`${n}{${i}}`,Object.assign({},t.stack.env),t.configuration).mml(),s=t.options.units.ugly?{}:{bevelled:!0},c=t.create("node","mfrac",[o,r],s);t.Push(c)}});new g("units",{units:p.Unit,unitfrac:p.UnitFrac,nicefrac:p.NiceFrac});const m=c.create("units",{[o.HANDLER]:{[r.MACRO]:["units"]},[o.OPTIONS]:{units:{loose:!1,ugly:!1}}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/units","4.0.0","tex-extension"),a({_:{input:{tex:{units:{UnitsConfiguration:e}}}}})})();