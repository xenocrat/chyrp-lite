(()=>{"use strict";var t={d:(e,a)=>{for(var r in a)t.o(a,r)&&!t.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:a[r]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{AutoOpen:()=>v});var a={};t.r(a),t.d(a,{default:()=>V});var r={};t.r(r),t.d(r,{PhysicsConfiguration:()=>J});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,i=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),o=(n.MathJax,MathJax._.input.tex.HandlerTypes),s=o.ConfigurationType,c=o.HandlerType,l=MathJax._.input.tex.Configuration,m=l.Configuration,u=(l.ConfigurationHandler,l.ParserConfiguration,MathJax._.input.tex.StackItem),p=(u.MmlStack,u.BaseItem),g=MathJax._.input.tex.ParseUtil,d=(g.KeyValueDef,g.KeyValueTypes,g.ParseUtil),h=MathJax._.input.tex.NodeUtil.default,x=MathJax._.input.tex.TexParser.default;class v extends p{constructor(){super(...arguments),this.openCount=0}get kind(){return"auto open"}get isOpen(){return!0}toMml(t=!0,e){if(!t)return super.toMml(t,e);const a=this.factory.configuration.parser,r=this.getProperty("right");if(this.getProperty("smash")){const t=super.toMml(),e=a.create("node","mpadded",[t],{height:0,depth:0});this.Clear(),this.Push(a.create("node","TeXAtom",[e]))}r&&this.Push(new x(r,a.stack.env,a.configuration).mml());const n=d.fenced(this.factory.configuration,this.getProperty("open"),super.toMml(),this.getProperty("close"),this.getProperty("big"));return h.removeProperties(n,"open","close","texClass"),n}closing(t){return t===this.getProperty("close")&&!this.openCount--}checkItem(t){if(t.getProperty("pre-autoclose"))return p.fail;if(t.getProperty("autoclose"))return this.getProperty("ignore")?(this.Clear(),[[],!0]):[[this.toMml()],!0];if(t.isKind("mml")&&1===t.Size()){const e=t.toMml();e.isKind("mo")&&e.getText()===this.getProperty("open")&&this.openCount++}return super.checkItem(t)}}v.errors=Object.assign(Object.create(p.errors),{stop:["ExtraOrMissingDelims","Extra open or missing close delimiter"]});const f=MathJax._.input.tex.TokenMap,y=(f.parseResult,f.AbstractTokenMap,f.RegExpMap,f.AbstractParseMap,f.CharacterMap),M=(f.DelimiterMap,f.MacroMap),P=f.CommandMap,q=f.EnvironmentMap,A=MathJax._.input.tex.base.BaseMethods,$=(A.splitAlignArray,A.default),b=MathJax._.input.tex.TexError.default,G=MathJax._.core.MmlTree.MmlNode,N=G.TEXCLASS,k=(G.TEXCLASSNAMES,G.MATHVARIANTS,G.indentAttributes,G.AbstractMmlNode,G.AbstractMmlTokenNode,G.AbstractMmlLayoutNode,G.AbstractMmlBaseNode,G.AbstractMmlEmptyNode,G.TextNode,G.XMLNode,MathJax._.input.tex.NodeFactory.NodeFactory),E={"(":")","[":"]","{":"}","|":"|"},F=/^(b|B)i(g{1,2})$/,w=[65,90],S=[97,122],C=[913,937],O=[945,969],Q=[48,57];function T(t,e){return t>=e[0]&&t<=e[1]}function D(t,e,a,r){const n=t.configuration.parser,i=k.createToken(t,e,a,r),o=r.codePointAt(0);return 1===r.length&&!n.stack.env.font&&n.stack.env.vectorFont&&(T(o,w)||T(o,S)||T(o,C)||T(o,Q)||T(o,O)&&n.stack.env.vectorStar||h.getAttribute(i,"accent"))&&h.setAttribute(i,"mathvariant",n.stack.env.vectorFont),i}function B(t,e,a,r,n){const i=new x(r,t.stack.env,t.configuration).mml();t.Push(t.itemFactory.create(e,i));const o=t.GetNext(),s=E[o];if(!s)return;let c="",l="",m="";const u=n.includes(o);if("{"===o){m=t.GetArgument(a),c=u?"\\left\\{":"",l=u?"\\right\\}":"";const e=`${c} ${m} ${l}`;return t.string=e+t.string.slice(t.i),void(t.i=0)}u&&(t.i++,t.Push(t.itemFactory.create("auto open").setProperties({open:o,close:s})))}function I([t,e,a],r,n){return r&&n?`\\left\\langle{${t}}\\middle\\vert{${e}}\\middle\\vert{${a}}\\right\\rangle`:r?`\\langle{${t}}\\vert{${e}}\\vert{${a}}\\rangle`:`\\left\\langle{${t}}\\right\\vert{${e}}\\left\\vert{${a}}\\right\\rangle`}const V={Quantity(t,e,a="(",r=")",n=!1,i="",o=""){const s=!!n&&t.GetStar();let c=t.GetNext();const l=t.i;let m=null;if("\\"===c){if(t.i++,m=t.GetCS(),!m.match(F)){const e=t.create("node","mrow");return t.Push(d.fenced(t.configuration,a,e,r)),void(t.i=l)}c=t.GetNext()}let u=E[c];if(n&&"{"!==c)throw new b("MissingArgFor","Missing argument for %1",t.currentCS);if(!u){const e=t.create("node","mrow");return t.Push(d.fenced(t.configuration,a,e,r)),void(t.i=l)}if(i){const e=t.create("token","mi",{texClass:N.OP},i);o&&h.setAttribute(e,"mathvariant",o),t.Push(t.itemFactory.create("fn",e))}if("{"===c){let i=t.GetArgument(e);return c=n?a:"\\{",u=n?r:"\\}",i=s?`${c} ${i} ${u}`:m?`\\${m}l${c} ${i} \\${m}r${u}`:`\\left${c} ${i} \\right${u}`,void t.Push(new x(i,t.stack.env,t.configuration).mml())}t.i++,t.Push(t.itemFactory.create("auto open").setProperties({open:c,close:u,big:m}))},Eval(t,e){const a=t.GetStar(),r=t.GetNext();if("("===r||"["===r)return t.i++,void t.Push(t.itemFactory.create("auto open").setProperties({open:r,close:"|",smash:a,right:"\\vphantom{\\int}"}));let n="\\left.\\vphantom{\\int}\\right|";if("{"===r){const r=t.GetArgument(e);n=`\\left.${a?`\\smash{${r}}`:r}\\vphantom{\\int}\\right|`}t.string=t.string.substring(0,t.i)+n+t.string.slice(t.i)},Commutator(t,e,a="[",r="]"){const n=t.GetStar();let i=t.GetNext(),o=null;if("\\"===i){if(t.i++,o=t.GetCS(),!o.match(F))throw new b("MissingArgFor","Missing argument for %1",t.currentCS);i=t.GetNext()}if("{"!==i)throw new b("MissingArgFor","Missing argument for %1",t.currentCS);let s=t.GetArgument(e)+","+t.GetArgument(e);s=n?`${a} ${s} ${r}`:o?`\\${o}l${a} ${s} \\${o}r${r}`:`\\left${a} ${s} \\right${r}`,t.Push(new x(s,t.stack.env,t.configuration).mml())},VectorBold(t,e){const a=t.GetStar(),r=t.GetArgument(e),n=t.configuration.nodeFactory.get("token"),i=t.stack.env.font;delete t.stack.env.font,t.configuration.nodeFactory.set("token",D),t.stack.env.vectorFont=a?"bold-italic":"bold",t.stack.env.vectorStar=a;const o=new x(r,t.stack.env,t.configuration).mml();i&&(t.stack.env.font=i),delete t.stack.env.vectorFont,delete t.stack.env.vectorStar,t.configuration.nodeFactory.set("token",n),t.Push(o)},StarMacro(t,e,a,...r){const n=t.GetStar(),i=[];if(a)for(let r=i.length;r<a;r++)i.push(t.GetArgument(e));let o=r.join(n?"*":"");o=d.substituteArgs(t,i,o),t.string=d.addArgs(t,o,t.string.slice(t.i)),t.i=0,d.checkMaxMacros(t)},OperatorApplication(t,e,a,...r){B(t,"fn",e,a,r)},VectorOperator(t,e,a,...r){B(t,"mml",e,a,r)},Expression(t,e,a=!0,r=""){r=r||e.slice(1);const n=a?t.GetBrackets(e):null;let i=t.create("token","mi",{texClass:N.OP},r);if(n){const e=new x(n,t.stack.env,t.configuration).mml();i=t.create("node","msup",[i,e])}t.Push(t.itemFactory.create("fn",i)),"("===t.GetNext()&&(t.i++,t.Push(t.itemFactory.create("auto open").setProperties({open:"(",close:")"})))},Qqtext(t,e,a){const r=(t.GetStar()?"":"\\quad")+"\\text{"+(a||t.GetArgument(e))+"}\\quad ";t.string=t.string.slice(0,t.i)+r+t.string.slice(t.i)},Differential(t,e,a){const r=t.GetBrackets(e),n=null!=r?"^{"+r+"}":" ",i="("===t.GetNext(),o="{"===t.GetNext();let s=a+n;if(i||o)if(o){s+=t.GetArgument(e);const a=new x(s,t.stack.env,t.configuration).mml();t.Push(t.create("node","TeXAtom",[a],{texClass:N.OP}))}else t.Push(new x(s,t.stack.env,t.configuration).mml()),t.i++,t.Push(t.itemFactory.create("auto open").setProperties({open:"(",close:")"}));else{s+=t.GetArgument(e,!0)||"";const a=new x(s,t.stack.env,t.configuration).mml();t.Push(a)}},Derivative(t,e,a,r){const n=t.GetStar(),i=t.GetBrackets(e);let o=1;const s=[];for(s.push(t.GetArgument(e));"{"===t.GetNext()&&o<a;)s.push(t.GetArgument(e)),o++;let c=!1,l=" ",m=" ";a>2&&s.length>2?(l="^{"+(s.length-1)+"}",c=!0):null!=i&&(a>2&&s.length>1&&(c=!0),l=`^{${i}}`,m=l);const u=n?"\\flatfrac":"\\frac",p=s.length>1?s[0]:"",g=s.length>1?s[1]:s[0];let d="";for(let t,e=2;t=s[e];e++)d+=r+" "+t;const h=`${u}{${r}${l}${p}}{${r} ${g}${m} ${d}}`;t.Push(new x(h,t.stack.env,t.configuration).mml()),"("===t.GetNext()&&(t.i++,t.Push(t.itemFactory.create("auto open").setProperties({open:"(",close:")",ignore:c})))},Bra(t,e){const a=t.GetStar(),r=t.GetArgument(e);let n="",i=!1,o=!1;if("\\"===t.GetNext()){let e=t.i;t.i++;const a=t.GetCS(),r=t.lookup(c.MACRO,a);r&&"ket"===r.token?(i=!0,e=t.i,o=t.GetStar(),"{"===t.GetNext()?n=t.GetArgument(a,!0):(t.i=e,o=!1)):t.i=e}let s="";s=i?a||o?`\\langle{${r}}\\vert{${n}}\\rangle`:`\\left\\langle{${r}}\\middle\\vert{${n}}\\right\\rangle`:a?`\\langle{${r}}\\vert`:`\\left\\langle{${r}}\\right\\vert{${n}}`,t.Push(new x(s,t.stack.env,t.configuration).mml())},Ket(t,e){const a=t.GetStar(),r=t.GetArgument(e),n=a?`\\vert{${r}}\\rangle`:`\\left\\vert{${r}}\\right\\rangle`;t.Push(new x(n,t.stack.env,t.configuration).mml())},BraKet(t,e){const a=t.GetStar(),r=t.GetArgument(e);let n=null;"{"===t.GetNext()&&(n=t.GetArgument(e,!0));let i="";i=null==n?a?`\\langle{${r}}\\vert{${r}}\\rangle`:`\\left\\langle{${r}}\\middle\\vert{${r}}\\right\\rangle`:a?`\\langle{${r}}\\vert{${n}}\\rangle`:`\\left\\langle{${r}}\\middle\\vert{${n}}\\right\\rangle`,t.Push(new x(i,t.stack.env,t.configuration).mml())},KetBra(t,e){const a=t.GetStar(),r=t.GetArgument(e);let n=null;"{"===t.GetNext()&&(n=t.GetArgument(e,!0));let i="";i=null==n?a?`\\vert{${r}}\\rangle\\!\\langle{${r}}\\vert`:`\\left\\vert{${r}}\\middle\\rangle\\!\\middle\\langle{${r}}\\right\\vert`:a?`\\vert{${r}}\\rangle\\!\\langle{${n}}\\vert`:`\\left\\vert{${r}}\\middle\\rangle\\!\\middle\\langle{${n}}\\right\\vert`,t.Push(new x(i,t.stack.env,t.configuration).mml())},Expectation(t,e){const a=t.GetStar(),r=a&&t.GetStar(),n=t.GetArgument(e);let i=null;"{"===t.GetNext()&&(i=t.GetArgument(e,!0));const o=n&&i?I([i,n,i],a,r):a?`\\langle {${n}} \\rangle`:`\\left\\langle {${n}} \\right\\rangle`;t.Push(new x(o,t.stack.env,t.configuration).mml())},MatrixElement(t,e){const a=t.GetStar(),r=a&&t.GetStar(),n=I([t.GetArgument(e),t.GetArgument(e),t.GetArgument(e)],a,r);t.Push(new x(n,t.stack.env,t.configuration).mml())},MatrixQuantity(t,e,a){const r=t.GetStar(),n=a?"smallmatrix":"array";let i="",o="",s="";switch(t.GetNext()){case"{":i=t.GetArgument(e);break;case"(":t.i++,o=r?"\\lgroup":"(",s=r?"\\rgroup":")",i=t.GetUpTo(e,")");break;case"[":t.i++,o="[",s="]",i=t.GetUpTo(e,"]");break;case"|":t.i++,o="|",s="|",i=t.GetUpTo(e,"|");break;default:o="(",s=")"}const c=(o?"\\left":"")+`${o}\\begin{${n}}{} ${i}\\end{${n}}`+(o?"\\right":"")+s;t.Push(new x(c,t.stack.env,t.configuration).mml())},IdentityMatrix(t,e){const a=t.GetArgument(e),r=parseInt(a,10);if(isNaN(r))throw new b("InvalidNumber","Invalid number");if(r<=1)return t.string="1"+t.string.slice(t.i),void(t.i=0);const n=Array(r).fill("0"),i=[];for(let t=0;t<r;t++){const e=n.slice();e[t]="1",i.push(e.join(" & "))}t.string=i.join("\\\\ ")+t.string.slice(t.i),t.i=0},XMatrix(t,e){const a=t.GetStar(),r=t.GetArgument(e),n=t.GetArgument(e),i=t.GetArgument(e);let o=parseInt(n,10),s=parseInt(i,10);if(isNaN(o)||isNaN(s)||s.toString()!==i||o.toString()!==n)throw new b("InvalidNumber","Invalid number");if(o=o<1?1:o,s=s<1?1:s,!a){const e=Array(s).fill(r).join(" & "),a=Array(o).fill(e).join("\\\\ ");return t.string=a+t.string.slice(t.i),void(t.i=0)}let c="";if(1===o&&1===s)c=r;else if(1===o){const t=[];for(let e=1;e<=s;e++)t.push(`${r}_{${e}}`);c=t.join(" & ")}else if(1===s){const t=[];for(let e=1;e<=o;e++)t.push(`${r}_{${e}}`);c=t.join("\\\\ ")}else{const t=[];for(let e=1;e<=o;e++){const a=[];for(let t=1;t<=s;t++)a.push(`${r}_{{${e}}{${t}}}`);t.push(a.join(" & "))}c=t.join("\\\\ ")}t.string=c+t.string.slice(t.i),t.i=0},PauliMatrix(t,e){const a=t.GetArgument(e);let r=a.slice(1);switch(a[0]){case"0":r+=" 1 & 0\\\\ 0 & 1";break;case"1":case"x":r+=" 0 & 1\\\\ 1 & 0";break;case"2":case"y":r+=" 0 & -i\\\\ i & 0";break;case"3":case"z":r+=" 1 & 0\\\\ 0 & -1"}t.string=r+t.string.slice(t.i),t.i=0},DiagonalMatrix(t,e,a){if("{"!==t.GetNext())return;const r=t.i;t.GetArgument(e);const n=t.i;t.i=r+1;const i=[];let o="",s=t.i;for(;s<n;){try{o=t.GetUpTo(e,",")}catch(e){t.i=n,i.push(t.string.slice(s,n-1));break}s=t.i,i.push(o)}t.string=function(t,e){const a=t.length,r=[];for(let n=0;n<a;n++)r.push(Array(e?a-n:n+1).join("&")+`\\mqty{${t[n]}}`);return r.join("\\\\ ")}(i,a)+t.string.slice(n),t.i=0},AutoClose(t,e,a){let r=t.stack.Top();if(r.isKind("over")&&(r=t.stack.Top(2)),!r.isKind("auto open")||!r.closing(e))return!1;const n=t.create("token","mo",{texClass:a},e);return t.Push(t.itemFactory.create("close").setProperties({"pre-autoclose":!0})),t.Push(t.itemFactory.create("mml",n).setProperties({autoclose:!0})),!0},Vnabla(t,e){const a=t.options.physics.arrowdel?"\\vec{\\gradientnabla}":"{\\gradientnabla}";return t.Push(new x(a,t.stack.env,t.configuration).mml())},DiffD(t,e){const a=t.options.physics.italicdiff?"d":"{\\rm d}";return t.Push(new x(a,t.stack.env,t.configuration).mml())},Macro:$.Macro,NamedFn:$.NamedFn,Array:$.Array},_=MathJax._.input.tex.TexConstants.TexConstant,j=MathJax._.input.tex.ParseMethods.default;new P("Physics-automatic-bracing-macros",{quantity:V.Quantity,qty:V.Quantity,pqty:[V.Quantity,"(",")",!0],bqty:[V.Quantity,"[","]",!0],vqty:[V.Quantity,"|","|",!0],Bqty:[V.Quantity,"\\{","\\}",!0],absolutevalue:[V.Quantity,"|","|",!0],abs:[V.Quantity,"|","|",!0],norm:[V.Quantity,"\\|","\\|",!0],evaluated:V.Eval,eval:V.Eval,order:[V.Quantity,"(",")",!0,"O",_.Variant.CALLIGRAPHIC],commutator:V.Commutator,comm:V.Commutator,anticommutator:[V.Commutator,"\\{","\\}"],acomm:[V.Commutator,"\\{","\\}"],poissonbracket:[V.Commutator,"\\{","\\}"],pb:[V.Commutator,"\\{","\\}"]}),new y("Physics-vector-mo",j.mathchar0mo,{dotproduct:["\u22c5",{mathvariant:_.Variant.BOLD}],vdot:["\u22c5",{mathvariant:_.Variant.BOLD}],crossproduct:"\xd7",cross:"\xd7",cp:"\xd7",gradientnabla:["\u2207",{mathvariant:_.Variant.BOLD}],divsymbol:"\xf7",divisionsymbol:"\xf7"}),new y("Physics-vector-mi",j.mathchar0mi,{real:["\u211c",{mathvariant:_.Variant.NORMAL}],imaginary:["\u2111",{mathvariant:_.Variant.NORMAL}]}),new P("Physics-vector-macros",{vnabla:V.Vnabla,vectorbold:V.VectorBold,vb:V.VectorBold,vectorarrow:[V.StarMacro,1,"\\vec{\\vb","{#1}}"],va:[V.StarMacro,1,"\\vec{\\vb","{#1}}"],vectorunit:[V.StarMacro,1,"\\hat{\\vb","{#1}}"],vu:[V.StarMacro,1,"\\hat{\\vb","{#1}}"],gradient:[V.OperatorApplication,"\\vnabla","(","["],grad:[V.OperatorApplication,"\\vnabla","(","["],divergence:[V.VectorOperator,"\\vnabla\\vdot","(","["],div:[V.VectorOperator,"\\vnabla\\vdot","(","["],curl:[V.VectorOperator,"\\vnabla\\crossproduct","(","["],laplacian:[V.OperatorApplication,"\\nabla^2","(","["]}),new P("Physics-expressions-macros",{sin:V.Expression,sinh:V.Expression,arcsin:V.Expression,asin:V.Expression,cos:V.Expression,cosh:V.Expression,arccos:V.Expression,acos:V.Expression,tan:V.Expression,tanh:V.Expression,arctan:V.Expression,atan:V.Expression,csc:V.Expression,csch:V.Expression,arccsc:V.Expression,acsc:V.Expression,sec:V.Expression,sech:V.Expression,arcsec:V.Expression,asec:V.Expression,cot:V.Expression,coth:V.Expression,arccot:V.Expression,acot:V.Expression,exp:[V.Expression,!1],log:V.Expression,ln:V.Expression,det:[V.Expression,!1],Pr:[V.Expression,!1],tr:[V.Expression,!1],trace:[V.Expression,!1,"tr"],Tr:[V.Expression,!1],Trace:[V.Expression,!1,"Tr"],rank:V.NamedFn,erf:[V.Expression,!1],Residue:[V.Macro,"\\mathrm{Res}"],Res:[V.OperatorApplication,"\\Residue","(","[","{"],principalvalue:[V.OperatorApplication,"{\\cal P}"],pv:[V.OperatorApplication,"{\\cal P}"],PV:[V.OperatorApplication,"{\\rm P.V.}"],Re:[V.OperatorApplication,"\\mathrm{Re}","{"],Im:[V.OperatorApplication,"\\mathrm{Im}","{"],sine:[V.NamedFn,"sin"],hypsine:[V.NamedFn,"sinh"],arcsine:[V.NamedFn,"arcsin"],asine:[V.NamedFn,"asin"],cosine:[V.NamedFn,"cos"],hypcosine:[V.NamedFn,"cosh"],arccosine:[V.NamedFn,"arccos"],acosine:[V.NamedFn,"acos"],tangent:[V.NamedFn,"tan"],hyptangent:[V.NamedFn,"tanh"],arctangent:[V.NamedFn,"arctan"],atangent:[V.NamedFn,"atan"],cosecant:[V.NamedFn,"csc"],hypcosecant:[V.NamedFn,"csch"],arccosecant:[V.NamedFn,"arccsc"],acosecant:[V.NamedFn,"acsc"],secant:[V.NamedFn,"sec"],hypsecant:[V.NamedFn,"sech"],arcsecant:[V.NamedFn,"arcsec"],asecant:[V.NamedFn,"asec"],cotangent:[V.NamedFn,"cot"],hypcotangent:[V.NamedFn,"coth"],arccotangent:[V.NamedFn,"arccot"],acotangent:[V.NamedFn,"acot"],exponential:[V.NamedFn,"exp"],logarithm:[V.NamedFn,"log"],naturallogarithm:[V.NamedFn,"ln"],determinant:[V.NamedFn,"det"],Probability:[V.NamedFn,"Pr"]}),new P("Physics-quick-quad-macros",{qqtext:V.Qqtext,qq:V.Qqtext,qcomma:[V.Macro,"\\qqtext*{,}"],qc:[V.Macro,"\\qqtext*{,}"],qcc:[V.Qqtext,"c.c."],qif:[V.Qqtext,"if"],qthen:[V.Qqtext,"then"],qelse:[V.Qqtext,"else"],qotherwise:[V.Qqtext,"otherwise"],qunless:[V.Qqtext,"unless"],qgiven:[V.Qqtext,"given"],qusing:[V.Qqtext,"using"],qassume:[V.Qqtext,"assume"],qsince:[V.Qqtext,"since"],qlet:[V.Qqtext,"let"],qfor:[V.Qqtext,"for"],qall:[V.Qqtext,"all"],qeven:[V.Qqtext,"even"],qodd:[V.Qqtext,"odd"],qinteger:[V.Qqtext,"integer"],qand:[V.Qqtext,"and"],qor:[V.Qqtext,"or"],qas:[V.Qqtext,"as"],qin:[V.Qqtext,"in"]}),new P("Physics-derivative-macros",{diffd:V.DiffD,flatfrac:[V.Macro,"\\left.#1\\middle/#2\\right.",2],differential:[V.Differential,"\\diffd"],dd:[V.Differential,"\\diffd"],variation:[V.Differential,"\\delta"],var:[V.Differential,"\\delta"],derivative:[V.Derivative,2,"\\diffd"],dv:[V.Derivative,2,"\\diffd"],partialderivative:[V.Derivative,3,"\\partial"],pderivative:[V.Derivative,3,"\\partial"],pdv:[V.Derivative,3,"\\partial"],functionalderivative:[V.Derivative,2,"\\delta"],fderivative:[V.Derivative,2,"\\delta"],fdv:[V.Derivative,2,"\\delta"]}),new P("Physics-bra-ket-macros",{bra:V.Bra,ket:V.Ket,innerproduct:V.BraKet,ip:V.BraKet,braket:V.BraKet,outerproduct:V.KetBra,dyad:V.KetBra,ketbra:V.KetBra,op:V.KetBra,expectationvalue:V.Expectation,expval:V.Expectation,ev:V.Expectation,matrixelement:V.MatrixElement,matrixel:V.MatrixElement,mel:V.MatrixElement}),new P("Physics-matrix-macros",{matrixquantity:V.MatrixQuantity,mqty:V.MatrixQuantity,pmqty:[V.Macro,"\\mqty(#1)",1],Pmqty:[V.Macro,"\\mqty*(#1)",1],bmqty:[V.Macro,"\\mqty[#1]",1],vmqty:[V.Macro,"\\mqty|#1|",1],smallmatrixquantity:[V.MatrixQuantity,!0],smqty:[V.MatrixQuantity,!0],spmqty:[V.Macro,"\\smqty(#1)",1],sPmqty:[V.Macro,"\\smqty*(#1)",1],sbmqty:[V.Macro,"\\smqty[#1]",1],svmqty:[V.Macro,"\\smqty|#1|",1],matrixdeterminant:[V.Macro,"\\vmqty{#1}",1],mdet:[V.Macro,"\\vmqty{#1}",1],smdet:[V.Macro,"\\svmqty{#1}",1],identitymatrix:V.IdentityMatrix,imat:V.IdentityMatrix,xmatrix:V.XMatrix,xmat:V.XMatrix,zeromatrix:[V.Macro,"\\xmat{0}{#1}{#2}",2],zmat:[V.Macro,"\\xmat{0}{#1}{#2}",2],paulimatrix:V.PauliMatrix,pmat:V.PauliMatrix,diagonalmatrix:V.DiagonalMatrix,dmat:V.DiagonalMatrix,antidiagonalmatrix:[V.DiagonalMatrix,!0],admat:[V.DiagonalMatrix,!0]}),new q("Physics-aux-envs",j.environment,{smallmatrix:[V.Array,null,null,null,"c","0.333em",".2em","S",1]}),new M("Physics-characters",{"|":[V.AutoClose,N.ORD],")":V.AutoClose,"]":V.AutoClose});const J=m.create("physics",{[s.HANDLER]:{macro:["Physics-automatic-bracing-macros","Physics-vector-macros","Physics-vector-mo","Physics-vector-mi","Physics-derivative-macros","Physics-expressions-macros","Physics-quick-quad-macros","Physics-bra-ket-macros","Physics-matrix-macros"],[c.CHARACTER]:["Physics-characters"],[c.ENVIRONMENT]:["Physics-aux-envs"]},[s.ITEMS]:{[v.prototype.kind]:v},[s.OPTIONS]:{physics:{italicdiff:!1,arrowdel:!1}}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/physics","4.0.0","tex-extension"),i({_:{input:{tex:{physics:{PhysicsConfiguration:r,PhysicsItems:e,PhysicsMethods:a}}}}})})();