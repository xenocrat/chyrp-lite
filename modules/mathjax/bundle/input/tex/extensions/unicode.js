(()=>{"use strict";var t={d:(e,n)=>{for(var a in n)t.o(n,a)&&!t.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:n[a]})},o:(t,e)=>Object.prototype.hasOwnProperty.call(t,e),r:t=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})}},e={};t.r(e),t.d(e,{UnicodeConfiguration:()=>C});const n=("undefined"!=typeof window?window:global).MathJax._.components.global,a=(n.GLOBAL,n.isObject,n.combineConfig,n.combineDefaults,n.combineWithMathJax),o=(n.MathJax,MathJax._.input.tex.HandlerTypes),i=o.ConfigurationType,r=o.HandlerType,c=MathJax._.input.tex.Configuration,s=c.Configuration,u=(c.ConfigurationHandler,c.ParserConfiguration,MathJax._.input.tex.TexError.default),l=MathJax._.input.tex.TokenMap,d=(l.parseResult,l.AbstractTokenMap,l.RegExpMap,l.AbstractParseMap,l.CharacterMap,l.DelimiterMap,l.MacroMap,l.CommandMap),m=(l.EnvironmentMap,MathJax._.input.tex.UnitUtil.UnitUtil),h=MathJax._.input.tex.NodeUtil.default,p=MathJax._.util.Entities,f=(p.options,p.entities,p.add,p.remove,p.translate,p.numeric),g=MathJax._.input.tex.base.BaseConfiguration,x=g.Other,M=(g.BaseTags,g.BaseConfiguration,{}),b={Unicode(t,e){const n=t.GetBrackets(e);let a=null,o="";if(n&&(n.replace(/ /g,"").match(/^(\d+(\.\d*)?|\.\d+),(\d+(\.\d*)?|\.\d+)$/)?(a=n.replace(/ /g,"").split(/,/),o=t.GetBrackets(e)||""):o=n),o.match(/;/))throw new u("BadFont","Font name for %1 can't contain semicolons",t.currentCS);const i=m.trimSpaces(t.GetArgument(e)).replace(/^0x/,"x");if(!i.match(/^(x[0-9A-Fa-f]+|[0-9]+)$/))throw new u("BadUnicode","Argument to %1 must be a number",t.currentCS);const r=parseInt(i.match(/^x/)?"0"+i:i);M[r]?o||(o=M[r][2]):M[r]=[800,200,o,r],a&&(M[r][0]=Math.floor(1e3*parseFloat(a[0])),M[r][1]=Math.floor(1e3*parseFloat(a[1])));const c=t.stack.env.font,s={};o?(M[r][2]=s.fontfamily=o.replace(/'/g,"'"),c&&(c.match(/bold/)&&(s.fontweight="bold"),c.match(/italic|-mathit/)&&(s.fontstyle="italic"))):c&&(s.mathvariant=c);const l=t.create("token","mtext",s,f(i));h.setProperty(l,"unicode",!0),t.Push(l)},RawUnicode(t,e){const n=t.GetArgument(e).trim();if(!n.match(/^[0-9A-F]{1,6}$/))throw new u("BadRawUnicode","Argument to %1 must a hexadecimal number with 1 to 6 digits",t.currentCS);const a=parseInt(n,16);t.string=String.fromCodePoint(a)+t.string.substring(t.i),t.i=0},Char(t,e){let n;const a=t.GetNext();let o="";const i=t.string.substring(t.i);if("'"===a)n=i.match(/^'([0-7]{1,7}) ?/u),n&&(o=String.fromCodePoint(parseInt(n[1],8)));else if('"'===a)n=i.match(/^"([0-9A-F]{1,6}) ?/),n&&(o=String.fromCodePoint(parseInt(n[1],16)));else if("`"===a){if(n=i.match(/^`(?:(\\\S)|(.))/u),n)if(n[2])o=n[2];else{t.i+=2;const e=[...t.GetCS()];if(e.length>1)throw new u("InvalidAlphanumeric","Invalid alphanumeric constant for %1",t.currentCS);o=e[0],n=[""]}}else n=i.match(/^([0-9]{1,7}) ?/),n&&(o=String.fromCodePoint(parseInt(n[1])));if(!o)throw new u("MissingNumber","Missing numeric constant for %1",t.currentCS);t.i+=n[0].length,o>="0"&&o<="9"?t.Push(t.create("token","mn",{},o)):o.match(/[A-Za-z]/)?t.Push(t.create("token","mi",{},o)):x(t,o)}};new d("unicode",{unicode:b.Unicode,U:b.RawUnicode,char:b.Char});const C=s.create("unicode",{[i.HANDLER]:{[r.MACRO]:["unicode"]}});MathJax.loader&&MathJax.loader.checkVersion("[tex]/unicode","4.0.0","tex-extension"),a({_:{input:{tex:{unicode:{UnicodeConfiguration:e}}}}})})();