(()=>{"use strict";var e={d:(t,r)=>{for(var a in r)e.o(r,a)&&!e.o(t,a)&&Object.defineProperty(t,a,{enumerable:!0,get:r[a]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{BraketItem:()=>x});var r={};e.r(r),e.d(r,{default:()=>S});var a={};e.r(a),e.d(a,{BraketConfiguration:()=>v});const o=("undefined"!=typeof window?window:global).MathJax._.components.global,s=(o.GLOBAL,o.isObject,o.combineConfig,o.combineDefaults,o.combineWithMathJax),n=(o.MathJax,MathJax._.input.tex.HandlerTypes),i=n.ConfigurationType,c=n.HandlerType,l=MathJax._.input.tex.Configuration,h=l.Configuration,p=(l.ConfigurationHandler,l.ParserConfiguration,MathJax._.input.tex.StackItem),M=(p.MmlStack,p.BaseItem),d=MathJax._.core.MmlTree.MmlNode,m=d.TEXCLASS,u=(d.TEXCLASSNAMES,d.MATHVARIANTS,d.indentAttributes,d.AbstractMmlNode,d.AbstractMmlTokenNode,d.AbstractMmlLayoutNode,d.AbstractMmlBaseNode,d.AbstractMmlEmptyNode,d.TextNode,d.XMLNode,MathJax._.input.tex.ParseUtil),b=(u.KeyValueDef,u.KeyValueTypes,u.ParseUtil),g=MathJax._.util.lengths,k=(g.BIGDIMEN,g.UNITS,g.RELUNITS,g.MATHSPACE),y=(g.length2em,g.percent,g.em),f=(g.px,y(k.thinmathspace));class x extends M{constructor(){super(...arguments),this.barNodes=[]}get kind(){return"braket"}get isOpen(){return!0}checkItem(e){return e.isKind("close")?e.getProperty("braketbar")?(this.barNodes.push(...super.toMml(!0,!0).childNodes),this.Clear(),M.fail):[[this.factory.create("mml",this.toMml())],!0]:e.isKind("mml")?(this.Push(e.toMml()),this.getProperty("single")?[[this.toMml()],!0]:M.fail):super.checkItem(e)}toMml(e=!0,t){let r=super.toMml(e,t);if(!e)return r;const a=this.getProperty("open"),o=this.getProperty("close");if(this.barNodes.length&&(r=this.create("node","inferredMrow",[...this.barNodes,r])),this.getProperty("stretchy"))return this.getProperty("space")&&(r=this.create("node","inferredMrow",[this.create("token","mspace",{width:f}),r,this.create("token","mspace",{width:f})])),b.fenced(this.factory.configuration,a,r,o);const s={fence:!0,stretchy:!1,symmetric:!0,texClass:m.OPEN},n=this.create("token","mo",s,a);s.texClass=m.CLOSE;const i=this.create("token","mo",s,o);return this.create("node","mrow",[n,r,i],{open:a,close:o})}}const P=MathJax._.input.tex.TokenMap,A=(P.parseResult,P.AbstractTokenMap,P.RegExpMap,P.AbstractParseMap,P.CharacterMap,P.DelimiterMap,P.MacroMap),C=P.CommandMap,B=(P.EnvironmentMap,MathJax._.input.tex.base.BaseMethods),N=(B.splitAlignArray,B.default),T=MathJax._.input.tex.TexError.default,S={Braket(e,t,r,a,o,s,n=!1){const i=e.GetNext();if(""===i)throw new T("MissingArgFor","Missing argument for %1",e.currentCS);let c=!0;"{"===i&&(e.i++,c=!1);const l=e.itemFactory.create("braket");l.setProperties({barcount:0,barmax:s,open:r,close:a,stretchy:o,single:c,space:n}),e.Push(l),l.env.braketItem=e.stack.height-1},Bar(e,t){let r="|"===t?"|":"\u2016";const a=e.stack.height-e.stack.env.braketItem,o=e.stack.Top(a);if(!o||!o.isKind("braket")||o.getProperty("barcount")>=o.getProperty("barmax"))return!1;if("|"===r&&"|"===e.GetNext()&&(e.i++,r="\u2016"),!o.getProperty("stretchy")){const t=e.create("token","mo",{stretchy:!1,"data-braketbar":!0,texClass:m.ORD},r);return e.Push(t),!0}const s=e.itemFactory.create("close").setProperty("braketbar",!0);return e.Push(s),o.barNodes.push(e.create("node","TeXAtom",[],{texClass:m.CLOSE}),e.create("token","mo",{stretchy:!0,"data-braketbar":!0,texClass:m.BIN},r),e.create("node","TeXAtom",[],{texClass:m.OPEN})),o.setProperty("barcount",o.getProperty("barcount")+1),!0},Macro:N.Macro};new C("Braket-macros",{bra:[S.Macro,"{\\langle {#1} \\vert}",1],ket:[S.Macro,"{\\vert {#1} \\rangle}",1],braket:[S.Braket,"\u27e8","\u27e9",!1,1/0],set:[S.Braket,"{","}",!1,1],Bra:[S.Macro,"{\\left\\langle {#1} \\right\\vert}",1],Ket:[S.Macro,"{\\left\\vert {#1} \\right\\rangle}",1],Braket:[S.Braket,"\u27e8","\u27e9",!0,1/0],Set:[S.Braket,"{","}",!0,1,!0],ketbra:[S.Macro,"{\\vert {#1} \\rangle\\langle {#2} \\vert}",2],Ketbra:[S.Macro,"{\\left\\vert {#1} \\right\\rangle\\left\\langle {#2} \\right\\vert}",2],"|":S.Bar}),new A("Braket-characters",{"|":S.Bar});const v=h.create("braket",{[i.HANDLER]:{[c.CHARACTER]:["Braket-characters"],[c.MACRO]:["Braket-macros"]},[i.ITEMS]:{[x.prototype.kind]:x},[i.PRIORITY]:3});MathJax.loader&&MathJax.loader.checkVersion("[tex]/braket","4.0.0","tex-extension"),s({_:{input:{tex:{braket:{BraketConfiguration:a,BraketItems:t,BraketMethods:r}}}}})})();