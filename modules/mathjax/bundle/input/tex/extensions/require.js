(()=>{"use strict";var e={d:(t,a)=>{for(var o in a)e.o(a,o)&&!e.o(t,o)&&Object.defineProperty(t,o,{enumerable:!0,get:a[o]})},o:(e,t)=>Object.prototype.hasOwnProperty.call(e,t),r:e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})}},t={};e.r(t),e.d(t,{RequireConfiguration:()=>j,RequireLoad:()=>A,RequireMethods:()=>J,options:()=>_});const a=("undefined"!=typeof window?window:global).MathJax._.components.global,o=(a.GLOBAL,a.isObject,a.combineConfig,a.combineDefaults,a.combineWithMathJax),r=(a.MathJax,MathJax._.input.tex.HandlerTypes),n=r.ConfigurationType,i=r.HandlerType,s=MathJax._.input.tex.Configuration,p=s.Configuration,u=s.ConfigurationHandler,c=(s.ParserConfiguration,MathJax._.input.tex.TokenMap),l=(c.parseResult,c.AbstractTokenMap,c.RegExpMap,c.AbstractParseMap,c.CharacterMap,c.DelimiterMap,c.MacroMap,c.CommandMap),d=(c.EnvironmentMap,MathJax._.input.tex.TexError.default),f=("undefined"!=typeof window?window:global).MathJax._.components.startup,g=(f.Startup,f.MathJax),h=(f.CONFIG,MathJax._.components.package),x=(h.PackageError,h.Package),m=("undefined"!=typeof window?window:global).MathJax._.components.loader,O=(m.PathFilters,m.Loader),M=(m.MathJax,m.CONFIG),w=MathJax._.mathjax.mathjax,b=MathJax._.util.Options,q=(b.isObject,b.APPEND,b.REMOVE,b.OPTIONS,b.Expandable,b.expandable),y=(b.makeArray,b.keys,b.copy,b.insert,b.defaultOptions,b.userOptions,b.selectOptions,b.selectOptionsFromKeys,b.separateOptions,b.lookup,g.config);function k(e,t){const a=e.parseOptions.options.require,o=e.parseOptions.packageData.get("require").required,r=t.substring(a.prefix.length);if(!o.includes(r)){o.push(r);const a=function(e,t=[]){const a=e.parseOptions.options.require.prefix,o=[];for(const r of t)if(r.substring(0,a.length)===a)try{k(e,r)}catch(e){if(!e.retry)throw e;o.push(e.retry)}return o.length?Promise.all(o):null}(e,M.dependencies[t]);a?w.retryAfter(a.then((()=>P(e,t,r)))):P(e,t,r)}}function P(e,t,a){const o=u.get(a);if(o){let r=y[t]||{};o.options&&1===Object.keys(o.options).length&&o.options[a]&&(r={[a]:r}),e.configuration.add(a,e,r);const n=e.parseOptions.packageData.get("require").configured;o.preprocessors.length&&!n.has(a)&&(n.set(a,!0),w.retryAfter(Promise.resolve()))}}function A(e,t){var a,o;const r=e.options.require,n=r.allow,i=("["===t.substring(0,1)?"":r.prefix)+t;if(!(Object.hasOwn(n,i)?n[i]:Object.hasOwn(n,t)?n[t]:r.defaultAllow))throw new d("BadRequire",'Extension "%1" is not allowed to be loaded',i);const s=x.packages.get(i);if(s||w.retryAfter(O.load(i).catch((e=>{}))),s.hasFailed)throw new d("RequireFail",'Extension "%1" failed to load',t);const p=null===(a=M[i])||void 0===a?void 0:a.rendererExtensions,u=null===(o=g.startup.document)||void 0===o?void 0:o.menu;p&&u&&u.addRequiredExtensions(p),k(e.configuration.packageData.get("require").jax,i)}const J={Require(e,t){const a=e.GetArgument(t);if(a.match(/[^_a-zA-Z0-9]/)||""===a)throw new d("BadPackageName","Argument for %1 is not a valid package name",t);A(e,a),e.Push(e.itemFactory.create("null"))}},_={require:{allow:q({base:!1,autoload:!1,configmacros:!1,tagformat:!1,setoptions:!1,texhtml:!1}),defaultAllow:!0,prefix:"tex"}};new l("require",{require:J.Require});const j=p.create("require",{[n.HANDLER]:{[i.MACRO]:["require"]},[n.CONFIG]:function(e,t){t.parseOptions.packageData.set("require",{jax:t,required:[...t.options.packages],configured:new Map});const a=t.parseOptions.options.require,o=a.prefix;if(o.match(/[^_a-zA-Z0-9]/))throw Error("Illegal characters used in \\require prefix");M.paths[o]||(M.paths[o]="[mathjax]/input/tex/extensions"),a.prefix="["+o+"]/"},[n.OPTIONS]:_});MathJax.loader&&MathJax.loader.checkVersion("[tex]/require","4.0.0","tex-extension"),o({_:{input:{tex:{require:{RequireConfiguration:t}}}}})})();